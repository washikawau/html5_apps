declare module "enchant.js" {

    function enchant(...modules: string[]): void;

    type ActionParam = {
        time?: number,
        onactionstart?: () => void,
        onactiontick?: () => void,
        onactionend?: () => void,
    };

    class Action extends ActionEventTarget {
        constructor(param: ActionParam);
    }

    class ActionEventTarget extends EventTarget {
        constructor();
    }

    class BinaryInputManager extends InputManager {
        constructor(
            flagStore: object,
            activeEventNameSuffix: string,
            inactiveEventNameSuffix: string,
            source?: object,
        );
        activeEventNameSuffix: string;
        activeInputsNum: number;
        inactiveEventNameSuffix: string;
        bind(
            inputSource: BinaryInputSource,
            name: string,
        ): void;
        unbind(inputSource: BinaryInputSource);
    }

    class BinaryInputSource extends InputSource {
        constructor(identifier: string);
    }

    class CanvasLayer extends Group {
        constructor();
        _element: HTMLCanvasElement;
        height: number;
        width: number;
    }

    class CanvasScene extends Scene {
        constructor();
    }

    class Class {
        constructor(
            superclass?: () => object,
            definition?: object,
        );
        static create(
            superclass?: () => object,
            definition?: object,
        ): Class;
        static getInheritanceTree(): (() => object)[];
    }

    class Core extends EventTarget {
        constructor(
            width: number,
            height: number
        );
        _element: HTMLElement;
        assets: Map<string, object>;
        currentScene: Scene;
        fps: number;
        frame: number;
        height: number;
        input: object;
        static instance: Core
        loadingScene: Scene;
        ready: boolean;
        rootScene: Scene;
        running: boolean;
        scale: number;
        width: number;
        debug(): Deferred;
        static findExt(path: string): string;
        getElapsedTime(): number;
        keybind(
            key: number,
            button: string
        ): Core;
        keyunbind(key: number): Core;
        load(
            src: string,
            alias?: string,
            callback?: () => void,
            onerror?: () => void
        ): Deferred;
        pause(): void;
        popScene(): Scene;
        preload(assets: string | string[]): Core;
        pushScene(scene: Scene): Scene;
        removeScene(scene: Scene): Scene;
        replaceScene(scene: Scene): Scene;
        resume(): void;
        start(deferred?: Deferred): Deferred;
        stop(): void;
    }

    class Deferred {
        constructor();
        call(arg: object): void;
        error(func: () => void): void;
        fail(arg: object): void;
        next(func: () => void): void;
        static next(func: () => void): Deferred;
        static parallel(arg: Deferred[]): Deferred;
    }

    class DOMScene extends Scene {
        constructor();
    }

    class DOMSound extends EventTarget {
        constructor();
        _element: HTMLAudioElement;
        currentTime: number;
        duration: number;
        volume: number;
        clone(): DOMSound;
        static load(
            src: string,
            type?: string,
            callback?: () => void,
            onerror?: () => void,
        ): DOMSound;
        pause(): void;
        play(): void;
        stop(): void;
    }

    type EasingFunc = (t: number, b: number, c: number, d: number) => number;

    class Easing {
        constructor();
        static LINEAR: EasingFunc;
        static SWING: EasingFunc;
        static QUAD_EASEIN: EasingFunc;
        static QUAD_EASEOUT: EasingFunc;
        static QUAD_EASEINOUT: EasingFunc;
        static CUBIC_EASEIN: EasingFunc;
        static CUBIC_EASEOUT: EasingFunc;
        static CUBIC_EASEINOUT: EasingFunc;
        static QUART_EASEIN: EasingFunc;
        static QUART_EASEOUT: EasingFunc;
        static QUART_EASEINOUT: EasingFunc;
        static QUINT_EASEIN: EasingFunc;
        static QUINT_EASEOUT: EasingFunc;
        static QUINT_EASEINOUT: EasingFunc;
        static SIN_EASEIN: EasingFunc;
        static SIN_EASEOUT: EasingFunc;
        static SIN_EASEINOUT: EasingFunc;
        static CIRC_EASEIN: EasingFunc;
        static CIRC_EASEOUT: EasingFunc;
        static CIRC_EASEINOUT: EasingFunc;
        static ELASTIC_EASEIN: EasingFunc;
        static ELASTIC_EASEOUT: EasingFunc;
        static ELASTIC_EASEINOUT: EasingFunc;
        static BOUNCE_EASEOUT: EasingFunc;
        static BOUNCE_EASEIN: EasingFunc;
        static BOUNCE_EASEINOUT: EasingFunc;
        static BACK_EASEIN: EasingFunc;
        static BACK_EASEOUT: EasingFunc;
        static BACK_EASEINOUT: EasingFunc;
        static EXPO_EASEIN: EasingFunc;
        static EXPO_EASEOUT: EasingFunc;
        static EXPO_EASEINOUT: EasingFunc;
    }

    class Entity extends Node {
        constructor();
        backgroundColor: string;
        buttonMode: string;
        buttonPressed: boolean;
        compositeOperation: string;
        debugColor: string;
        height: number;
        opacity: number;
        originX: number;
        originY: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        touchEnabled: boolean;
        visible: boolean;
        width: number;
        disableCollection(): void;
        enableCollection(): void;
        intersect(other: object): boolean;
        rotate(deg: number): void;
        scale(
            x?: number,
            y?: number,
        ): void;
        within(
            other: object,
            distance?: number,
        ): boolean;
    }

    class ENV {
        static BROWSER: string;
        static CANVAS_DRAWING_METHODS: string[];
        static COLOR_DETECTION_LEVEL: boolean;
        static KEY_BIND_TABLE: object;
        static PREVENT_DEFAULT_KEY_CODES: number[];
        static RETINA_DISPLAY: boolean;
        static SOUND_ENABLED_ON_MOBILE_SAFARI: boolean;
        static TOUCH_ENABLED: boolean;
        static USE_ANIMATION: boolean;
        static USE_DEFAULT_EVENT_TAGS: string[];
        static USE_FLASH_SOUND: boolean;
        static USE_TOUCH_TO_START_SCENE: boolean;
        static USE_WEBAUDIO: boolean;
        static VENDOR_PREFIX: string;
        static VERSION: string;
    }

    class Event {
        constructor(type: string);
        static A_BUTTON_DOWN: string;
        static A_BUTTON_UP: string;
        static ACTION_ADDED: string;
        static ACTION_END: string;
        static ACTION_REMOVED: string;
        static ACTION_START: string;
        static ACTION_TICK: string;
        static ADDED: string;
        static ADDED_TO_SCENE: string;
        static ADDED_TO_TIMELINE: string;
        static ANIMATION_END: string;
        static B_BUTTON_DOWN: string;
        static B_BUTTON_UP: string;
        static CHILD_ADDED: string;
        static CHILD_REMOVED: string;
        static CORE_RESIZE: string;
        static DOWN_BUTTON_DOWN: string;
        static DOWN_BUTTON_UP: string;
        static ENTER: string;
        static ENTER_FRAME: string;
        static ERROR: void;
        static EXIT: string;
        static EXIT_FRAME: string;
        static INPUT_CHANGE: string;
        static INPUT_END: string;
        static INPUT_START: string;
        static INPUT_STATE_CHANGED: string;
        static LEFT_BUTTON_DOWN: string;
        static LEFT_BUTTON_UP: string;
        static LOAD: string;
        localX: number;
        localY: number;
        static PROGRESS: string;
        static REMOVED: string;
        static REMOVED_FROM_SCENE: string;
        static REMOVED_FROM_TIMELINE: string;
        static RENDER: string;
        static RIGHT_BUTTON_DOWN: string;
        static RIGHT_BUTTON_UP: string;
        target: object;
        static TOUCH_END: string;
        static TOUCH_MOVE: string;
        static TOUCH_START: string;
        type: string;
        static UP_BUTTON_DOWN: string;
        static UP_BUTTON_UP: string;
        x: number;
        y: number;
    }

    class CustomEvent<T = unknown> extends Event {
        constructor(
            type: string,
            eventInitDict?: CustomEventInit<T>
        ): CustomEvent<T>;
    }

    class EventTarget {
        constructor();
        addEventListener(
            type: string,
            listener: (e: Event) => void
        ): void;
        clearEventListener(type: string): void;
        dispatchEvent(e: Event): void;
        on(
            type: string,
            listener: (e: Event) => void
        ): void;
        removeEventListener(
            type: string,
            listener: (e: Event) => void
        ): void;
        onload(e: Event): void;
        onerror(e: Event): void;
        oncoreresize(e: Event): void;
        onprogress(e: Event): void;
        onenterframe(e: Event): void;
        onexitframe(e: Event): void;
        onenter(e: Event): void;
        onexit(e: Event): void;
        onchildadded(e: Event): void;
        onadded(e: Event): void;
        onaddedtoscene(e: Event): void;
        onchildremoved(e: Event): void;
        onremoved(e: Event): void;
        onremovedfromscene(e: Event): void;
        ontouchstart(e: Event): void;
        ontouchmove(e: Event): void;
        ontouchend(e: Event): void;
        onrender(e: Event): void;
        oninputstart(e: Event): void;
        oninputchange(e: Event): void;
        oninputend(e: Event): void;
        oninputstatechanged(e: Event): void;
        onleftbuttondown(e: Event): void;
        onleftbuttonup(e: Event): void;
        onrightbuttondown(e: Event): void;
        onrightbuttonup(e: Event): void;
        onupbuttondown(e: Event): void;
        onupbuttonup(e: Event): void;
        ondownbuttondown(e: Event): void;
        ondownbuttonup(e: Event): void;
        onabuttondown(e: Event): void;
        onabuttonup(e: Event): void;
        onbbuttondown(e: Event): void;
        onbbuttonup(e: Event): void;
    }

    class Game extends Core {
        constructor(width: number, height: number);
    }

    class Group extends Node {
        constructor();
        childNodes: Node[];
        firstChild: Node;
        lastChild: Node;
        originX: number;
        originY: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        addChild(node: Node): void;
        insertBefore(
            node: Node,
            reference: Node,
        ): void;
        removeChild(node: Node): void;
    }

    class InputManager extends EventTarget {
        constructor(
            valueStore: object,
            source: object,
        );
        broadcastTarget: EventTarget[];
        source: object;
        valueStore: object;
        addBroadcastTarget(eventTarget: EventTarget): void;
        bind(
            inputSource: InputSource,
            name: string,
        ): void;
        broadcastEvent(e: Event): void;
        changeState(
            name: string,
            data: object,
        ): void;
        removeBroadcastTarget(eventTarget: EventTarget): void;
        unbind(inputSource: InputSource): void;
    }

    class InputSource extends EventTarget {
        constructor(identifier: string);
        identifier: string;
        notifyStateChange(data: object): void;
    }

    class KeyboardInputManager extends BinaryInputManager {
        constructor(
            dom: HTMLElement,
            flagStore: object,
        );
        keybind(
            keyCode: number,
            name: string,
        ): void;
        keyunbind(keyCode: number): void;
    }

    class KeyboardInputSource extends BinaryInputSource {
        constructor(keyCode: string);
        static getByKeyCode(keyCode: number): KeyboardInputSource;
    }

    class Label extends Entity {
        constructor(text?: string);
        color: string;
        font: string;
        text: string;
        textAlign: string;
    }

    class LoadingScene extends Scene {
        constructor();
    }

    class Map extends Entity {
        constructor(
            tileWidth: number,
            tileHeight: number,
        );
        collisionData: number[][];
        image: Surface;
        tileHeight: number;
        tileWidth: number;
        checkTile(
            x: number,
            y: number,
        ): object;
        hitTest(
            x: number,
            y: number,
        ): boolean;
        loadData(...data: number[][]): void;
    }

    class Node extends EventTarget {
        constructor();
        age: number;
        parentNode: Group;
        scene: Scene
        x: number;
        y: number;
        tl: Timeline;
        moveBy(
            x: number,
            y: number,
        ): void;
        moveTo(
            x: number,
            y: number,
        ): void;
    }

    class ParallelAction extends Action {
        constructor();
        actions: Action[];
        endedActions: Action[];
    }

    class Scene extends Group {
        constructor();
        _element: HTMLElement;
        backgroundColor: string;
    }

    class Sprite extends Entity {
        constructor(
            width: number,
            height: number,
        );
        get frame(): number;
        set frame(v: number | number[]);
        image: Surface;
    }

    class Surface extends EventTarget {
        constructor(
            width: number,
            height: number,
        );
        _element: HTMLCanvalElement;
        context: CanvasRenderingContext2D;
        height: number;
        width: number;
        clear(): void;
        draw(image: Surface): void;
        getPixel(
            x: number,
            y: number,
        ): number[];
        static load(
            src: string,
            callback: () => void,
            onerror?: () => void,
        ): Surface;
        setPixel(
            x: number,
            y: number,
            r: number,
            g: number,
            b: number,
            a: number,
        ): void;
        toDataURL(): string;
    }

    class Timeline extends EventTarget {
        constructor(node: Node);
        action(params: object): Timeline;
        add(action: Action): Timeline;
        and(): Timeline;
        clear(): Timeline;
        cue(cue: object): Timeline;
        delay(time: number): Timeline;
        exec(func: () => void): Timeline;
        fadeIn(
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        fadeOut(
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        fadeTo(
            opacity: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        hide(): Timeline;
        loop(): Timeline;
        moveBy(
            x: number,
            y: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        moveTo(
            x: number,
            y: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        moveX(
            x: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        moveY(
            y: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        next(remainingTime: object): void;
        pause(): Timeline;
        removeFromScene(): Timeline;
        repeat(
            func: () => void,
            time: number,
        ): Timeline;
        resume(): Timeline;
        rotateBy(
            deg: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        rotateTo(
            deg: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        scaleBy(
            scaleX: number,
            scaleY: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        scaleTo(
            scaleX: number,
            scaleY: number,
            time: number,
            easing?: EasingFunc,
        ): Timeline;
        setFrameBased(): void;
        setTimeBased(): void;
        show(): Timeline;
        skip(frames: number): Timeline;
        then(func: () => void): number;
        tick(elapsed: number): void;
        tween(params: object): Timeline;
        unloop(): Timeline;
        wait(time: number): Timeline;
        waitUntil(func: () => boolean): Timeline;
    }

    class Tween extends Action {
        constructor(params: {
            time: number,
            easing?: EasingFunc
        });
    }

    class WebAudioSound extends EventTarget {
        constructor();
        currentTime: number;
        duration: number;
        volume: number;
        clone(): WebAudioSound;
        static load(
            src: string,
            type?: string,
            callback?: () => void,
            onerror?: () => void,
        ): WebAudioSound;
        pause(): void;
        play(dup?: boolean): void;
        stop(): void;
    }

}
