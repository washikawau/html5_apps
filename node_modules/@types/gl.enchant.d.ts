declare module "gl.enchant.js" {
    import { EventTarget } from "enchant.js";
    import { Core as OrigCore2, } from "nineleap.enchant.js";

    class Core extends OrigCore2 {
        constructor(
            width: number,
            height: number,
            startImage?: string,
            endImage?: string,
        );
    }

    class FrameBuffer {
        constructor(
            width: number,
            height: number,
        );
        bind(): void;
        unbind(): void;
        destroy(): void;
    }

    class Shader {
        constructor(
            vshader: string,
            fshader: string,
        );
        vShaderSource: string;
        fShaderSource: string;
        compile(): void;
        use(): void;
        setAttributes(params: object): void;
        setUniforms(params: object): void;
        destroy(): void;
    }

    type Mat4 = [
        number, number, number, number,
        number, number, number, number,
        number, number, number, number,
        number, number, number, number,
    ];

    type Vec3 = [number, number, number];
    type Vec4 = [number, number, number, number];
    type Color3 = [number, number, number];
    type Color4 = [number, number, number, number];
    type Quat4 = [number, number, number, number];

    class Quat {
        constructor(
            x: number,
            y: number,
            z: number,
            rad: number,
        )
        slerp(
            another: Quat,
            ratio: number,
        ): Quat
        slerpApply(
            another: Quat,
            ratio: number,
        ): Quat
        toMat4(matrix: Mat4): Mat4;
        multiplyVec3(vector: Vec3): Vec3;
    }

    class Light3D extends EventTarget {
        constructor();
        color: Color3;
    }

    class AmbientLight extends Light3D {
        constructor();
    }

    class DirectionalLight extends Light3D {
        constructor();
        directionX: number;
        directionY: number;
        directionZ: number;
    }

    class PointLight extends Light3D {
        constructor();
        x: number;
        y: number;
        z: number;
    }

    class Texture {
        constructor(
            src?: string,
            opt?: object,
        );
        ambient: [number, number, number, number];
        diffuse: [number, number, number, number];
        specular: [number, number, number, number];
        emission: [number, number, number, number];
        shininess: number;
        src: string;
    }

    type BufferParam = {
        size: number,
        type: number,
        norm: boolean,
        stride: number,
        offset: number,
        btype: number,
        usage: number,
        Atype: RelativeIndexable<number>,
    };

    class Buffer {
        constructor(
            params: object,
            array?: number[],
        );
        bind(): void;
        unbind(): void;
        destroy(): void;
        static VERTICES: BufferParam;
        static NORMALS: BufferParam;
        static TEXCOORDS: BufferParam;
        static COLORS: BufferParam;
        static INDICES: BufferParam;
    }

    class Mesh {
        constructor();
        texture: Texture;
        vertices: number[];
        normals: number[];
        texCoords: number[];
        indices: number[];
        colors: number[];
        setBaseColor(color: Color4 | string): void;
        reverse(): void;
        destroy(): void;
    }

    class Sprite3D extends EventTarget {
        constructor();
        childNodes: Sprite3D[];
        scene: Scene3D | null;
        parentNode: Sprite3D | Scene3D | null;
        program: string;
        bounding: Bounding | BS | AABB;
        age: number;
        globalX: number;
        globalY: number;
        globalZ: number;
        tmpMat: Mat4;
        modelMat: Mat4;
        detectColor: Color4;
        clone(): Sprite3D;
        set(sprite: object): void;
        addChild(sprite: Sprite3D): void;
        removeChild(sprite: Sprite3D): void;
        intersect(another: Sprite3D): boolean;
        translate(
            x: number,
            y: number,
            z: number,
        ): Sprite3D;
        forward(speed: number): Sprite3D;
        sidestep(speed: number): Sprite3D;
        altitude(speed: number): Sprite3D;
        scale(
            x: number,
            y: number,
            z: number,
        ): void;
        name: string;
        rotation: Mat4;
        rotationSet(quat: Quat): void;
        rotationApply(quat: Quat): void;
        rotateRoll(rad: number): void;
        rotatePitch(rad: number): void;
        rotateYaw(rad: number): void;
        mesh: Mesh;
        matrix: Mat4;
        touchable: boolean;
        x: number;
        y: number;
        z: number;
        scaleX: number;
        scaleY: number;
        scaleZ: number;
    }

    class Camera3D {
        constructor();
        mat: Mat4;
        invMat: Mat4;
        invMatY: Mat4;
        projMat: Mat4;
        lookAt(sprite: Sprite3D): void;
        chase(
            sprite: Sprite3D,
            position: number,
            speed: number,
        ): void;
        forward(speed: number): void;
        sidestep(speed: number): void;
        altitude(speed: number): void;
        rotateRoll(rad: number): void;
        rotatePitch(rad: number): void;
        rotateYaw(rad: number): void;
        x: number;
        y: number;
        z: number;
        centerX: number;
        centerY: number;
        centerZ: number;
        upVectorX: number;
        upVectorY: number;
        upVectorZ: number;
    }

    class Scene3D extends EventTarget {
        constructor();
        childNodes: Sprite3D[];
        lights: PointLight[];
        identityMat: Mat4;
        backgroundColor: Color4;
        addChild(sprite: Sprite3D): void;
        removeChild(sprite: Sprite3D): void;
        setCamera(camera: Camera3D): void;
        getCamera(): Camera3D;
        setAmbientLight(light: AmbientLight): void;
        getAmbientLight(): AmbientLight;
        setDirectionalLight(light: DirectionalLight): void;
        getDirectionalLight(): DirectionalLight;
        addLight(light: PointLight): void;
        removeLight(light: PointLight): void;
    }

    class Bounding {
        constructor();
        type: string | "point";
        threshold: number;
        x: number;
        y: number;
        z: number;
        parent: { x: number, y: number, z: number };
        toBounding(another: Bounding): number;
        toBS(another: BS): number;
        toAABB(another: AABB): number;
        toOBB(another: OBB): number;
        intersect(another: Bounding): boolean;
    }

    class BS extends Bounding {
        constructor();
        radius: number;
    }

    class AABB extends Bounding {
        constructor();
        scale: number;
    }

    class OBB extends Bounding {
        constructor();
    }

    class State {
        constructor(
            position: Vec3,
            rotation: Quat4,
        );
        set(pose: State): void;
    }

    class Pose extends State {
        constructor(
            position: Vec3,
            rotation: Quat4,
        );
        getInterpolation(
            another: Pose,
            ratio: number,
        ): Pose;
    }

    class KeyFrameManager {
        constructor();
        length: number;
        addFrame(
            pose: object,
            frame: number,
        ): void;
        getFrame(frame: number): object;
        bake(): void;
    }

    class Bone extends State {
        constructor(
            name: string,
            head: Vec3,
            position: Vec3,
            rotation: Quat4,
        );
        addChild(child: Bone): void;
        removeChild(child: Bone): void;
        setPoses(poses: object): void;
    }

    class Skeleton {
        constructor();
        childNodes: Bone[];
        addChild(bone: Bone): void;
        removeChild(bone: Bone): void;
        setPoses(poses: object): void;
        solveFKs(): void;
        addIKControl(
            effector: Bone,
            target: Bone,
            bones: Bone[],
            maxangle: number,
            iteration: number,
        ): void;
        solveIKs(): void;
    }
}
